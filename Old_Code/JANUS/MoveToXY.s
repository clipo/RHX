/******************************************************************************
*
*   Janus WinPREP Test Script
*   ---------------------------------
*
*   Based On:       c:\packard\janus\bin\RandomGripperMoveTest.mpt
*   Generated By:   WinPREP Version 3.0.0.017
*   Date Generated: 06/04/10 15:35:28
*   Username:       Janus
*   System:         DHD5RV81
*
******************************************************************************/



// The name and path of this test.
char *pszTestName = "MoveToXY";
char *pszTestPath = "c:\\packard\\janus\\bin";


/******************************************************************************
*
*   Runtime Variable Definitions
*
******************************************************************************/

int    Rt_nExecProc_S1  = 100;
int		Balance_X = 400;
int		Balance_Y = 400;
int		Balance_Z = 250;
int		Balance_Theta = 90;

int		Balance_Z_Lift = 390;


int    Rt_nNbrOfErrorsX = 0;
int    Rt_nNbrOfErrorsY = 0;
int    Rt_nNbrOfErrorsZ = 0;
int    Rt_nNbrOfErrorsG = 0;
int    Rt_nNbrOfErrorsT = 0;
char   Rt_szMoveTextX[260];
char   Rt_szMoveTextY[260];
char   Rt_szMoveTextZ[260];
char   Rt_szMoveTextG[260];
char   Rt_szMoveTextT[260];
int    Rt_nNbrOfMovesMade   = 0;
double Rt_dXSpeed   = 420;
double Rt_dXRamp    = 550;
double Rt_dYSpeed   = 470;
double Rt_dYRamp    = 470;
double Rt_dZSpeed   = 100;
double Rt_dZRamp    = 1000;
double Rt_dTSpeed   = 100;
double Rt_dTRamp    = 100;
double Rt_dGSpeed   = 60;
double Rt_dGRamp    = 60;


int IniAllRtVariables()
{
    strcpy( Rt_szMoveTextX, "0 / 0" );
    strcpy( Rt_szMoveTextY, "0 / 0" );
    strcpy( Rt_szMoveTextZ, "0 / 0" );
    strcpy( Rt_szMoveTextG, "0 / 0" );
    strcpy( Rt_szMoveTextT, "0 / 0" );

    return 0;
}



/******************************************************************************
*
*   Runtime File Definitions
*
******************************************************************************/

char* NULL = 0; // Global NULL pointer value
    

int IniAllRtFileDefs()
{

    return 0;
}



/******************************************************************************
*
*   Sample List Definitions
*
******************************************************************************/


int IniAllRtSmpListDefs()
{

    return 0;
}



/******************************************************************************
*
*   Well Map Definitions
*
******************************************************************************/


int IniAllWellMapDefs()
{

    MSL_ReconcileWellMapDefs();

    return 0;
}



/******************************************************************************
*
*   Procedure Definitions
*
******************************************************************************/

MP2_PROC_CONTEXT_DEF C00_Initial_User_Query;
MP2_PROC_CONTEXT_DEF C01_Warn_User_to_Clear_Deck;
MP2_PROC_CONTEXT_DEF C02_Test_Setup;
MP2_PROC_CONTEXT_DEF C03_Random_Move_Loop;
MP2_PROC_CONTEXT_DEF C04_Wait_For_User_Response;
MP2_PROC_CONTEXT_DEF C05_LogResults;

int IniAllProcDefs()
{
    MSL_IniProcDef( &C00_Initial_User_Query, "Initial User Query", 1, 0, NULL, sizeof(MP2_PROC_CONTEXT_DEF) );
    MSL_IniProcDef( &C01_Warn_User_to_Clear_Deck, "Warn User to Clear Deck", 3, 0, NULL, sizeof(MP2_PROC_CONTEXT_DEF) );
    MSL_IniProcDef( &C02_Test_Setup, "Test Setup", 5, 0, NULL, sizeof(MP2_PROC_CONTEXT_DEF) );
    MSL_IniProcDef( &C03_Random_Move_Loop, "Random Move Loop", 7, 0, NULL, sizeof(MP2_PROC_CONTEXT_DEF) );
    MSL_IniProcDef( &C04_Wait_For_User_Response, "Wait For User Response", 9, 0, NULL, sizeof(MP2_PROC_CONTEXT_DEF) );
    MSL_IniProcDef( &C05_LogResults, "LogResults", 11, 0, NULL, sizeof(MP2_PROC_CONTEXT_DEF) );

    return 0;
}



/******************************************************************************
*
*   Labware Definitions
*
******************************************************************************/

int IniAllLabwareDefs()
{
    IniLabwareDef( "c:\\packard\\janus\\bin\\RandomGripperMoveTest_Labware.csv" );

    return 0;
}



/******************************************************************************
*
*   User Defined Functions
*
******************************************************************************/

//------------------------------------------------
// Uf_WaitForUser()
//------------------------------------------------

int Uf_WaitForUser(    // 0=Normal; 3=Abort; 12=Stop Procedure
    char*  pPCX )  // Address of procedure context information
{
    int nRet = 0;                       // Load return value into nRet
    MP2_PROC_CONTEXT_DEF* pPC = pPCX;   // Cast pPCX into local procedure context ptr


	MSL_SetControlFocus( 1, 116 );
	MSL_WaitControl( 1, 116, -1 );

    return nRet;
}
// End of Uf_WaitForUser()


//------------------------------------------------
// Uf_RandomMove()
//------------------------------------------------

int Uf_RandomMove(    // 0=Normal; 3=Abort; 12=Stop Procedure
    char*  pPCX )  // Address of procedure context information
{
    int nRet = 0;                       // Load return value into nRet
    MP2_PROC_CONTEXT_DEF* pPC = pPCX;   // Cast pPCX into local procedure context ptr

    int i, nRandom, nMotorMask;
    int WAIT=1, NOWAIT=0;
    int SIGNAL=1, NOSIGNAL=0;
    int bFaulted, bAnyFaulted, iButton;
    int zmotors;

    // motor IDs
    int nXMotor = 0x01;
    int nYMotor = 0x02;
    int nZMotor = 0x04;
    int nTMotor = 0x08;
    int nGMotor = 0x10;
    int nAllMotors = nXMotor | nYMotor | nZMotor | nTMotor | nGMotor;

    // motor targets
    double dXTarget, dYTarget, dZTarget, dTTarget, dGTarget;

    // motor min & max positions
    double dXMin = 0.0,    dXMax = 1000.0;
    double dYMin = 0.0,    dYMax = 325.0;
    double dZMin = 0.0,    dZMax = 245.0;
    double dTMin = -160.0, dTMax = 180.0;
    double dGMin = 0.0,    dGMax = 35.0;
 
    // Is this a 4 tip or an 8 tip?
    zmotors = MSL_NumberOfDilutors();

    
    //------------------------------------------------------------
    // Move gripper motors
    //------------------------------------------------------------
    
    if( MSL_IsInstrumentOpen() )
    {
        switch(Rt_nNbrOfMovesMade)
        {
            case 0: // move all home
                nMotorMask = nAllMotors;
                dXTarget = 0;
                dYTarget = 0;
                dZTarget = 0;
                dTTarget = 0;
                dGTarget = 0;
                break;

            case 1: // move y forward
                nMotorMask = nYMotor;
                dYTarget = dYMax;
                break;

            case 2: // move x left
                nMotorMask = nXMotor;
                dXTarget = dXMax;
                break;

            case 3: // move y back
                nMotorMask = nYMotor;
                dYTarget = dYMin;
                break;

            case 4: // move x right
                nMotorMask = nXMotor;
                dXTarget = dXMin;
                break;

            case 5: // move theta open 
                nMotorMask = nTMotor;
                dTTarget = dTMax;
                break;

            case 6: // move theta close
                nMotorMask = nTMotor;
                dTTarget = dTMin;
                break;

            case 7: // move gripper open 
                nMotorMask = nGMotor;
                dGTarget = dGMax;
                break;

            case 8: // move gripper close 
                nMotorMask = nGMotor;
                dGTarget = dGMax;
                break;

            default:
                // move all motors at random
                nMotorMask = nAllMotors;
                nRandom = rand();
                dXTarget = ((double) nRandom)  / 32767.0 * (dXMax - dXMin) + dXMin;
                nRandom = rand();
                dYTarget = ((double) nRandom)  / 32767.0 * (dYMax - dYMin) + dYMin;
                nRandom = rand();
                dZTarget = ((double) nRandom)  / 32767.0 * (dZMax - dZMin) + dZMin;
                nRandom = rand();
                dTTarget = ((double) nRandom)  / 32767.0 * (dTMax - dTMin) + dTMin;
                nRandom = rand();
                dGTarget = ((double) nRandom)  / 32767.0 * (dGMax - dGMin) + dGMin;
                break;
        }

        while(1)
        {
            bAnyFaulted = 0;
        
            printf( "\nX min,max,target = %f,%f,%f", dXMin, dXMax, dXTarget );
            printf( "\nY min,max,target = %f,%f,%f", dYMin, dYMax, dYTarget );
            printf( "\nZ min,max,target = %f,%f,%f", dZMin, dZMax, dZTarget );
            printf( "\nT min,max,target = %f,%f,%f", dTMin, dTMax, dTTarget );
            printf( "\nG min,max,target = %f,%f,%f \n", dGMin, dGMax, dGTarget );
         
            GRIP_MoveAbsolute(dXTarget, dYTarget, dZTarget, dTTarget, dGTarget, nMotorMask, WAIT, NOSIGNAL);

            GRIP_GetIsXFaulted(&bFaulted);
            if(bFaulted)
            {
                Rt_nNbrOfErrorsX ++;
                bAnyFaulted = 1;
            }

            GRIP_GetIsYFaulted(&bFaulted);
            if(bFaulted)
            {
                Rt_nNbrOfErrorsY ++;
                bAnyFaulted = 1;
            }

            GRIP_GetIsZFaulted(&bFaulted);
            if(bFaulted)
            {
                Rt_nNbrOfErrorsZ ++;
                bAnyFaulted = 1;
            }

            GRIP_GetIsTFaulted(&bFaulted);
            if(bFaulted)
            {
                Rt_nNbrOfErrorsT ++;
                bAnyFaulted = 1;
            }

            GRIP_GetIsGFaulted(&bFaulted);
            if(bFaulted)
            {
                Rt_nNbrOfErrorsG ++;
                bAnyFaulted = 1;
            }

            if(bAnyFaulted)
            {
                iButton=MSL_MessageDialog(0,"Motor Faulted","A gripper motor has faulted!",2,4,2,0);
                GRIP_ClearAllFaults();
                if(iButton == 3)
                    // retry
                    continue;
                if(iButton == 5)
                    // ignore
                    break;
                if(iButton == 4)
                    // abort
                    return 3;
            }
            else
                break;
        }
    }


    //------------------------------------------------------------
    // Bump total number of cycles
    //------------------------------------------------------------

    Rt_nNbrOfMovesMade++;

    //------------------------------------------------------------
    // Create status strings for the dialog box
    //------------------------------------------------------------

    sprintf( Rt_szMoveTextX, "%d / %d", Rt_nNbrOfErrorsX, Rt_nNbrOfMovesMade );
    sprintf( Rt_szMoveTextY, "%d / %d", Rt_nNbrOfErrorsY, Rt_nNbrOfMovesMade );
    sprintf( Rt_szMoveTextZ, "%d / %d", Rt_nNbrOfErrorsZ, Rt_nNbrOfMovesMade );
    sprintf( Rt_szMoveTextG, "%d / %d", Rt_nNbrOfErrorsG, Rt_nNbrOfMovesMade );
    sprintf( Rt_szMoveTextT, "%d / %d", Rt_nNbrOfErrorsT, Rt_nNbrOfMovesMade );

    //------------------------------------------------------------
    // Force the dialog to refresh
    //------------------------------------------------------------

    MSL_UpdateControl( 1, 101 );
    MSL_UpdateControl( 1, 102 );
    MSL_UpdateControl( 1, 103 );
    MSL_UpdateControl( 1, 104 );
    MSL_UpdateControl( 1, 105 );

    return nRet;
}
// End of Uf_RandomMove()


//------------------------------------------------
// Uf_TestSetup()
//------------------------------------------------

int Uf_TestSetup(    // 0=Normal; 3=Abort; 12=Stop Procedure
    char*  pPCX )  // Address of procedure context information
{
    int nRet = 0;                       // Load return value into nRet
    MP2_PROC_CONTEXT_DEF* pPC = pPCX;   // Cast pPCX into local procedure context ptr

    // motor IDs
    int nXMotor = 0;
    int nYMotor = 1;
    int nZMotor = 2;
    int nTMotor = 3;
    int nGMotor = 4;
    int nAllMotors = nXMotor | nYMotor | nZMotor | nTMotor | nGMotor;

    //---------------------------------------------
    // Create the results dialog
    //---------------------------------------------

    // Create the error count dialog
    MSL_CreateDialog(0, 1, -1, -1, -1, -1, "Gripper Arm Random Move Test Results", 1);

    // Create the X, Y, Z, G, and T motor error text boxes
    MSL_CreateLabel   (1,100,10, 2,20,1,"Errors / Moves", 0);
    MSL_CreateEditBox (1,101,10,-1,20,1,"X",      NULL, Rt_szMoveTextX, "TEXT", 0, 64, 0, 0, 8);
    MSL_CreateEditBox (1,102,10,-1,20,1,"Y",      NULL, Rt_szMoveTextY, "TEXT", 0, 64, 0, 0, 8);
    MSL_CreateEditBox (1,103,10,-1,20,1,"Z",      NULL, Rt_szMoveTextZ, "TEXT", 0, 64, 0, 0, 8);
    MSL_CreateEditBox (1,104,10,-1,20,1,"Gripper",NULL, Rt_szMoveTextG, "TEXT", 0, 64, 0, 0, 8);
    MSL_CreateEditBox (1,105,10,-1,20,1,"Theta",  NULL, Rt_szMoveTextT, "TEXT", 0, 64, 0, 0, 8);

    // Create the OK button
    MSL_CreatePushBtn (1,116,10,-1,20,1,"OK",NULL, 0, 0, 0x830);

    // Display the dialog
    MSL_ShowDialog( 1, 1, 0);

    //---------------------------------------------
    // Make sure the pipetting arm is parked
    //---------------------------------------------
    MSL_ParkPipetteArm();

    //---------------------------------------------
    // Set motor speeds and ramps
    //---------------------------------------------
    if(Rt_dXSpeed > 0.0)
        GRIP_SetVelocity(nXMotor, Rt_dXSpeed);
    if(Rt_dXRamp > 0.0)
        GRIP_SetAcceleration(nXMotor, Rt_dXRamp);

    if(Rt_dYSpeed > 0.0)
        GRIP_SetVelocity(nYMotor, Rt_dYSpeed);
    if(Rt_dYRamp > 0.0)
        GRIP_SetAcceleration(nYMotor, Rt_dYRamp);

    if(Rt_dZSpeed > 0.0)
        GRIP_SetVelocity(nZMotor, Rt_dZSpeed);
    if(Rt_dZRamp > 0.0)
        GRIP_SetAcceleration(nZMotor, Rt_dZRamp);

    if(Rt_dTSpeed > 0.0)
        GRIP_SetVelocity(nTMotor, Rt_dTSpeed);
    if(Rt_dTRamp > 0.0)
        GRIP_SetAcceleration(nTMotor, Rt_dTRamp);

    if(Rt_dGSpeed > 0.0)
        GRIP_SetVelocity(nGMotor, Rt_dGSpeed);
    if(Rt_dGRamp > 0.0)
        GRIP_SetAcceleration(nGMotor, Rt_dGRamp);

    return nRet;
}
// End of Uf_TestSetup()


//------------------------------------------------
// Uf_LogResults()
//------------------------------------------------

int Uf_LogResults(    // 0=Normal; 3=Abort; 12=Stop Procedure
    char*  pPCX )  // Address of procedure context information
{
    int nRet = 0;                       // Load return value into nRet
    MP2_PROC_CONTEXT_DEF* pPC = pPCX;   // Cast pPCX into local procedure context ptr

    char *pszLogFile = "RandomGripperTestLog.txt";
    char szTime[64];
    struct tm *newtime;
    time_t aclock;

    // get & format current date and time
    time( &aclock );                // Get time in seconds
    newtime = localtime( &aclock ); // Convert time to struct tm form
    strcpy(szTime, asctime(newtime));
    szTime[strlen(szTime)-1]=0;

    MSL_WriteFile(pszLogFile,"\r\nTest ended on %s after %d moves.\r\n", szTime, Rt_nNbrOfMovesMade);
    MSL_WriteFile(pszLogFile,"Error summary: X=%d, Y=%d, Z=%d, G=%d, T=%d\r\n",
        Rt_nNbrOfErrorsX, Rt_nNbrOfErrorsY, Rt_nNbrOfErrorsZ, Rt_nNbrOfErrorsG, Rt_nNbrOfErrorsT);
       

    return nRet;
}
// End of Uf_LogResults()




/******************************************************************************
*
*   Procedure Functions:
*
*   Each procedure name is prefixed with a 'P' followed by one or
*   more pairs of hexidecimal digits.  The number of pairs indicates
*   the nesting level of the procedure node in the test outline.
*   The value of each pair is the offset of the node at each level
*   from its parent.
*
******************************************************************************/

/******************************************************************************
*
*   P00_Initial_User_Query()
*
*   <Reserved for text entered into the procedure's comment page.>
*
******************************************************************************/

int P00_Initial_User_Query()
{
    MP2_PROC_CONTEXT_DEF *pPC = &C00_Initial_User_Query;
    int  nRet;              // Funct. return value
    int  nFileIndex = 0;    // Current File Index
    int  nLoopCount = 0;    // Number of unskipped procedure loops
    int  bDone;             // Last procedure loop flag
    int  nDlg;              // Dialog Id
    int  nCurPage;          // Current Dialog Page Number
    int  nNxtPage;          // Next Dialog Page Number
    int  nX, nY;            // Control origin
    int  nW, nH;            // Control size
    int  nMaxY = 0;         // Max Y position
    MP2_DATE stMinDate;     // Minimum Date
    MP2_DATE stMaxDate;     // Maximum Date
    MP2_TIME stMinTime;     // Minimum Time
    MP2_TIME stMaxTime;     // Maximum Time


    // Set the current procedure context.
    MSL_SetCurrentProcContext( pPC, 0, 0 );

    // Create the dialog box.
    nDlg = MSL_GetAvailableDialogId();
    MSL_CreateDialog( 0, nDlg, -1, -1, -1, -1,
                      "Initial User Query", 0 );

    // Create page 1: Label, prompts and collection.
    MSL_CreateLabel( nDlg, 3, 1, 1, 0, 1, "", 0 );
    MSL_CreateEditBox( nDlg, 4, -175, 3, 15, 1, "Number of movements to make", "Number of movement cycles to make", &Rt_nExecProc_S1, "INT", 1., 2000000000., 0., 0,  0x60 );
    MSL_GetControlGeom( nDlg, 4, &nX, &nY, &nW, &nH );
    if( nMaxY < (nY + nH) ) nMaxY = nY + nH;
    MSL_CreateCollection( nDlg, 1, "3,4", 0, 0 );
    MSL_ShowControl( nDlg, 1, 0 );

    // Create page 2: Label, prompts and collection.
    MSL_CreateLabel( nDlg, 5, 1, 1, 42, 1, "Gripper Motor Velocities and Accelerations", 0 );
    MSL_CreateEditBox( nDlg, 6, -175, 3, 15, 1, "X Velocity", "X velocity in mm/s (0=use machine default)", &Rt_dXSpeed, "DOUBLE", 0.000000, 900.000000, 0.000000, 0, 0x0 );
    MSL_CreateEditBox( nDlg, 7, -175, -1, 15, 1, "X Acceleration", "X acceleration in mm/s/s (0=use machine default)", &Rt_dXRamp, "DOUBLE", 0.000000, 900.000000, 0.000000, 0, 0x0 );
    MSL_CreateEditBox( nDlg, 8, -175, -1, 15, 1, "Y Velocity", "Y velocity in mm/s (0=use machine default)", &Rt_dYSpeed, "DOUBLE", 0.000000, 600.000000, 0.000000, 0, 0x0 );
    MSL_CreateEditBox( nDlg, 9, -175, -1, 15, 1, "Y Acceleration", "Y acceleration in mm/s/s (0=use machine default)", &Rt_dYRamp, "DOUBLE", 0.000000, 1200.000000, 0.000000, 0, 0x0 );
    MSL_CreateEditBox( nDlg, 10, -175, -1, 15, 1, "Z Velocity", "Z velocity in mm/s (0=use machine default)", &Rt_dZSpeed, "DOUBLE", 0.000000, 300.000000, 0.000000, 0, 0x0 );
    MSL_CreateEditBox( nDlg, 11, -175, -1, 15, 1, "Z Acceleration", "Z acceleration in mm/s/s (0=use machine defaultZ)", &Rt_dZRamp, "DOUBLE", 0.000000, 150.000000, 0.000000, 0, 0x0 );
    MSL_CreateEditBox( nDlg, 12, -175, -1, 15, 1, "Theta Velocity", "Theta velocity in deg/s (0=use machine default)", &Rt_dTSpeed, "DOUBLE", 0.000000, 105.000000, 0.000000, 0, 0x0 );
    MSL_CreateEditBox( nDlg, 13, -175, -1, 15, 1, "Theta Acceleration", "Theta acceleration in deg/s/s (0=use machine default)", &Rt_dTRamp, "DOUBLE", 0.000000, 9000.000000, 0.000000, 0, 0x0 );
    MSL_CreateEditBox( nDlg, 14, -175, -1, 15, 1, "Gripper Velocity", "Gripper velocity in mm/s (0=use machine default)", &Rt_dGSpeed, "DOUBLE", 0.000000, 65.000000, 0.000000, 0, 0x0 );
    MSL_CreateEditBox( nDlg, 15, -175, -1, 15, 1, "Gripper Acceleration", "Gripper acceleration in mm/s/s (0=use machine default)", &Rt_dGRamp, "DOUBLE", 0.000000, 5000.000000, 0.000000, 0, 0x0 );
    MSL_GetControlGeom( nDlg, 15, &nX, &nY, &nW, &nH );
    if( nMaxY < (nY + nH) ) nMaxY = nY + nH;
    MSL_CreateCollection( nDlg, 2, "5,6,7,8,9,10,11,12,13,14,15", 0, 0 );
    MSL_ShowControl( nDlg, 2, 0 );

    // Create push buttons...
    nMaxY += 28;
    MSL_CreatePushBtn( nDlg, 10001, 1, -nMaxY, 10, 1, "< &Back", "Display Previous Page", 0, 0, 0);
    MSL_CreatePushBtn( nDlg, 10002,-1, -nMaxY, 10, 1, "&Next >", "Display Next Page", 0, 0, 0);
    MSL_CreatePushBtn( nDlg, 10003,24, -nMaxY, 10, 1, "&Start", "Begin Test Execution", 0, 0, 0x10);
    MSL_CreatePushBtn( nDlg, 10004,-1, -nMaxY, 10, 1, "&Abort", "Quit Test Now", 0, 0, 0);

    // Procedure query loop.
    pPC->nProcLimit = 1;
    for( pPC->nProcLoop = 0; pPC->nProcLoop <= pPC->nProcLimit; pPC->nProcLoop++ )
    {
        nFileIndex = pPC->nProcLoop;

        // If at or past the last loop, set the done flag.
        bDone = (pPC->nProcLoop >= pPC->nProcLimit);

        // Child procedure calls would be written here...

        // If done, break now.
        if( bDone ) break;

        // Increment the loop count.
        nLoopCount++;

        // Reset the current procedure context.
        MSL_SetCurrentProcContext( pPC, 1, 0 );

        // Sound the buzzer for 1/8 second
        MSL_Beep( 500, 0.125 );

        // Display the dialog box.
        nCurPage = 0;
        nNxtPage = 1;
        MSL_ShowDialog( nDlg, 1, 0 );

        // Monitor user button selections...
        while( 1 )
        {
            // Was there a change page request?
            if( nCurPage != nNxtPage )
            {
                if( nCurPage > 0 )   // Hide current page (if any)
                {
                    MSL_ShowControl( nDlg, nCurPage, 0 );   // Hide current page
                }
                if( nNxtPage > 0 )   // Show next page (if any)
                {
                    MSL_ShowControl( nDlg, nNxtPage, 1 );   // Show next page
                    MSL_UpdateControl( nDlg, nNxtPage );    // Update control values on next page
                    MSL_SetControlFocus( nDlg, nNxtPage );  // Give Focus to first control on next page
                }
                else break;  // Quit if next page not > 0

                nCurPage = nNxtPage;
            }

            // Set button states according to the current page.
            MSL_EnableControl( nDlg, 10001, (nCurPage > 1) );
            MSL_EnableControl( nDlg, 10002, (nCurPage < 2) );
            MSL_ShowControl(   nDlg, 10003, (nCurPage == 2) );

            // Wait for the user to click a button.
            nRet = MSL_WaitControlList( nDlg, "10001,10002,10003,10004", 0, -1, 0 );

            switch( nRet )
            {
                case 10001:   // Back
                    nNxtPage = nCurPage - 1;
                    if( nNxtPage < 1 ) nNxtPage = 1;
                    break;

                case 10002:   // Next
                    nNxtPage = nCurPage + 1;
                    if( nNxtPage > 2 ) nNxtPage = 2;
                    break;

                case 10003:   // Start
                    nNxtPage = 0;
                    break;

                case 10004:   // Abort?
                    MSL_DeleteDialog( nDlg, 0 );
                    MSL_Abort();
                    return -1;
            }

        } //<End Monitor button selections>

        // Hide the dialog box.
        MSL_ShowDialog( nDlg, 0, 0 );

    } //<End Procedure Loop>

    // Delete the dialog box.
    MSL_DeleteDialog( nDlg, 0 );

    // Remove disposable tips (if any)
    MSL_RemoveDTs();

    return 0;

} //<End P00_Initial_User_Query()>



/******************************************************************************
*
*   P01_Check_Configuration()
*
*   <Reserved for text entered into the procedure's comment page.>
*
******************************************************************************/

int P01_Check_Configuration()
{
    MP2_PROC_CONTEXT_DEF *pPC = &C01_Check_Configuration;
    int  nRet;              // Funct. return value
    int  nFileIndex = 0;    // Current File Index
    int  nLoopCount = 0;    // Number of unskipped procedure loops
    int  bDone;             // Last procedure loop flag



    // Set the current procedure context.
    MSL_SetCurrentProcContext( pPC, 0, 0 );

	// Toplevel procedures start with dilutor number 1.
    EGS_SetNextDilutor( 1 );
    
    // Procedure loop.
    pPC->nProcLimit = 1;
    for( pPC->nProcLoop = 0; pPC->nProcLoop <= pPC->nProcLimit; pPC->nProcLoop++ )
    {
        nFileIndex = pPC->nProcLoop;

        // If at or past the last loop, set the done flag.
        bDone = (pPC->nProcLoop >= pPC->nProcLimit);

        // Child procedure calls would be written here...

        // If done, break now.
        if( bDone ) break;

        // Increment the loop count.
        nLoopCount++;

        // Reset the current procedure context.
        MSL_SetCurrentProcContext( pPC, 1, 0 );

        // Sound the buzzer for 1/8 second
        MSL_Beep( 500, 0.125 );

        // Display User Message.
        nRet = MSL_MessageDialog( 0,        // No dialog owner
                    "Warn User to Check Configuration",      // Dialog Title
                    "Check that the crucibles and balance are set for motion!",      // Dialog Message
                    1,      // Icon: Information
                    1,      // Btns: OK
                    1,      // Default to 1st button
                    0 );        // Reserved flags field

        // Test User Reply: 2=>Cancel, 7=>No
        if( (nRet == 2) || (nRet == 7) ) return -1;

    } //<End Procedure Loop>

    return 0;

} //<End P01_Check_Configuration()>



/******************************************************************************
*
*   P02_Test_Setup()
*
*   <Reserved for text entered into the procedure's comment page.>
*
******************************************************************************/

int P02_Test_Setup()
{
    MP2_PROC_CONTEXT_DEF *pPC = &C02_Test_Setup;
    int  nRet;              // Funct. return value
    int  nFileIndex = 0;    // Current File Index
    int  nLoopCount = 0;    // Number of unskipped procedure loops
    int  bDone;             // Last procedure loop flag


    // Set the current procedure context.
    MSL_SetCurrentProcContext( pPC, 0, 0 );

    // Toplevel procedures start with dilutor number 1.
    EGS_SetNextDilutor( 1 );

    // Procedure loop.
    pPC->nProcLimit = 1;
    for( pPC->nProcLoop = 0; pPC->nProcLoop <= pPC->nProcLimit; pPC->nProcLoop++ )
    {
        nFileIndex = pPC->nProcLoop;

        // If at or past the last loop, set the done flag.
        bDone = (pPC->nProcLoop >= pPC->nProcLimit);

        // Child procedure calls would be written here...

        // If done, break now.
        if( bDone ) break;

        // Increment the loop count.
        nLoopCount++;

        // Reset the current procedure context.
        MSL_SetCurrentProcContext( pPC, 1, 0 );

        // Make sure string parameters comming from a file are auto allocated
        MSL_SetRtFileStringAutoAlloc( 1 );

        // Invoke the User Function...
        nRet = Uf_TestSetup( pPC );
        if( nRet ==  3 ) return -1;    // Check for abort
        if( nRet == 12 ) return  0;    // Check for done

        // Release any auto allocated strings.
        MSL_SetRtFileStringAutoAlloc( 0 );

    } //<End Procedure Loop>

    return 0;

} //<End P02_Test_Setup()>


/******************************************************************************
*
*   P03_MoveToXYZ_Loop()
*
*   <Reserved for text entered into the procedure's comment page.>
*
******************************************************************************/

int P03_MoveToXYZ_Loop()
{
    MP2_PROC_CONTEXT_DEF *pPC = &C03_Random_Move_Loop;
    int  nRet;              // Funct. return value
    int  nFileIndex = 0;    // Current File Index
    int  nLoopCount = 0;    // Number of unskipped procedure loops
    int  bDone;             // Last procedure loop flag


    // Set the current procedure context.
    MSL_SetCurrentProcContext( pPC, 0, 0 );

    // Toplevel procedures start with dilutor number 1.
    EGS_SetNextDilutor( 1 );

    // Procedure loop.
    pPC->nProcLimit = Rt_nExecProc_S1;
    for( pPC->nProcLoop = 0; pPC->nProcLoop <= pPC->nProcLimit; pPC->nProcLoop++ )
    {
        nFileIndex = pPC->nProcLoop;

        // If at or past the last loop, set the done flag.
        bDone = (pPC->nProcLoop >= pPC->nProcLimit);

        // Child procedure calls would be written here...

        // If done, break now.
        if( bDone ) break;

        // Increment the loop count.
        nLoopCount++;

        // Reset the current procedure context.
        MSL_SetCurrentProcContext( pPC, 1, 0 );

        // Make sure string parameters comming from a file are auto allocated
        MSL_SetRtFileStringAutoAlloc( 1 );

        // Invoke the User Function...
        nRet = Uf_RandomMove( pPC );
        if( nRet ==  3 ) return -1;    // Check for abort
        if( nRet == 12 ) return  0;    // Check for done

        // Release any auto allocated strings.
        MSL_SetRtFileStringAutoAlloc( 0 );

    } //<End Procedure Loop>

    return 0;

} //<End P03_Random_Move_Loop()>




/******************************************************************************
*
*   P03_Random_Move_Loop()
*
*   <Reserved for text entered into the procedure's comment page.>
*
******************************************************************************/

int P03_Random_Move_Loop()
{
    MP2_PROC_CONTEXT_DEF *pPC = &C03_Random_Move_Loop;
    int  nRet;              // Funct. return value
    int  nFileIndex = 0;    // Current File Index
    int  nLoopCount = 0;    // Number of unskipped procedure loops
    int  bDone;             // Last procedure loop flag


    // Set the current procedure context.
    MSL_SetCurrentProcContext( pPC, 0, 0 );

    // Toplevel procedures start with dilutor number 1.
    EGS_SetNextDilutor( 1 );

    // Procedure loop.
    pPC->nProcLimit = Rt_nExecProc_S1;
    for( pPC->nProcLoop = 0; pPC->nProcLoop <= pPC->nProcLimit; pPC->nProcLoop++ )
    {
        nFileIndex = pPC->nProcLoop;

        // If at or past the last loop, set the done flag.
        bDone = (pPC->nProcLoop >= pPC->nProcLimit);

        // Child procedure calls would be written here...

        // If done, break now.
        if( bDone ) break;

        // Increment the loop count.
        nLoopCount++;

        // Reset the current procedure context.
        MSL_SetCurrentProcContext( pPC, 1, 0 );

        // Make sure string parameters comming from a file are auto allocated
        MSL_SetRtFileStringAutoAlloc( 1 );

        // Invoke the User Function...
        nRet = Uf_RandomMove( pPC );
        if( nRet ==  3 ) return -1;    // Check for abort
        if( nRet == 12 ) return  0;    // Check for done

        // Release any auto allocated strings.
        MSL_SetRtFileStringAutoAlloc( 0 );

    } //<End Procedure Loop>

    return 0;

} //<End P03_Random_Move_Loop()>



/******************************************************************************
*
*   P04_Wait_For_User_Response()
*
*   <Reserved for text entered into the procedure's comment page.>
*
******************************************************************************/

int P04_Wait_For_User_Response()
{
    MP2_PROC_CONTEXT_DEF *pPC = &C04_Wait_For_User_Response;
    int  nRet;              // Funct. return value
    int  nFileIndex = 0;    // Current File Index
    int  nLoopCount = 0;    // Number of unskipped procedure loops
    int  bDone;             // Last procedure loop flag


    // Set the current procedure context.
    MSL_SetCurrentProcContext( pPC, 0, 0 );

    // Toplevel procedures start with dilutor number 1.
    EGS_SetNextDilutor( 1 );

    // Procedure loop.
    pPC->nProcLimit = 1;
    for( pPC->nProcLoop = 0; pPC->nProcLoop <= pPC->nProcLimit; pPC->nProcLoop++ )
    {
        nFileIndex = pPC->nProcLoop;

        // If at or past the last loop, set the done flag.
        bDone = (pPC->nProcLoop >= pPC->nProcLimit);

        // Child procedure calls would be written here...

        // If done, break now.
        if( bDone ) break;

        // Increment the loop count.
        nLoopCount++;

        // Reset the current procedure context.
        MSL_SetCurrentProcContext( pPC, 1, 0 );

        // Make sure string parameters comming from a file are auto allocated
        MSL_SetRtFileStringAutoAlloc( 1 );

        // Invoke the User Function...
        nRet = Uf_WaitForUser( pPC );
        if( nRet ==  3 ) return -1;    // Check for abort
        if( nRet == 12 ) return  0;    // Check for done

        // Release any auto allocated strings.
        MSL_SetRtFileStringAutoAlloc( 0 );

    } //<End Procedure Loop>

    return 0;

} //<End P04_Wait_For_User_Response()>



/******************************************************************************
*
*   P05_LogResults()
*
*   <Reserved for text entered into the procedure's comment page.>
*
******************************************************************************/

int P05_LogResults()
{
    MP2_PROC_CONTEXT_DEF *pPC = &C05_LogResults;
    int  nRet;              // Funct. return value
    int  nFileIndex = 0;    // Current File Index
    int  nLoopCount = 0;    // Number of unskipped procedure loops
    int  bDone;             // Last procedure loop flag


    // Set the current procedure context.
    MSL_SetCurrentProcContext( pPC, 0, 0 );

    // Toplevel procedures start with dilutor number 1.
    EGS_SetNextDilutor( 1 );

    // Procedure loop.
    pPC->nProcLimit = 1;
    for( pPC->nProcLoop = 0; pPC->nProcLoop <= pPC->nProcLimit; pPC->nProcLoop++ )
    {
        nFileIndex = pPC->nProcLoop;

        // If at or past the last loop, set the done flag.
        bDone = (pPC->nProcLoop >= pPC->nProcLimit);

        // Child procedure calls would be written here...

        // If done, break now.
        if( bDone ) break;

        // Increment the loop count.
        nLoopCount++;

        // Reset the current procedure context.
        MSL_SetCurrentProcContext( pPC, 1, 0 );

        // Make sure string parameters comming from a file are auto allocated
        MSL_SetRtFileStringAutoAlloc( 1 );

        // Invoke the User Function...
        nRet = Uf_LogResults( pPC );
        if( nRet ==  3 ) return -1;    // Check for abort
        if( nRet == 12 ) return  0;    // Check for done

        // Release any auto allocated strings.
        MSL_SetRtFileStringAutoAlloc( 0 );

    } //<End Procedure Loop>

    return 0;

} //<End P05_LogResults()>



/******************************************************************************
*
*   main()
*
******************************************************************************/

int main(int argc, char **argv)
{
    int nErr;

    // Set the EGS dump table and single step modes as well as
    // the evaluation level.
    EGS_SetDumpMode( 0 );
    EGS_SetSingleStep( 0 );
    EGS_SetEvaluationLevel( 0 );

    // Initialize runtime variables.
    IniAllRtVariables();

    // Load Instrument Data
    nErr = MSL_CreateMachine(argv[0]);
    if( nErr ) return;

    // Initialize Instrument
    nErr = MSL_InitializeMachine( 0 );
    if( nErr ) return;

    // Initialize file, well map and labware definitions.
    IniAllRtFileDefs();
    IniAllRtSmpListDefs();
    IniAllWellMapDefs();
    IniAllProcDefs();
    IniAllLabwareDefs();

    // Call each 1st level procedure in the outline.
    // Quit test if any procedure returns a failure.
    nErr = P00_Initial_User_Query();
    if( nErr ) return;

    nErr = P01_Check_Configuration();
    if( nErr ) return;

    nErr = P02_Test_Setup();
    if( nErr ) return;

    nErr = P03_MoveToXYZ_Loop();
    if( nErr ) return;

    nErr = P04_Wait_For_User_Response();
    if( nErr ) return;

    nErr = P05_LogResults();
    if( nErr ) return;

}

// End of Script
