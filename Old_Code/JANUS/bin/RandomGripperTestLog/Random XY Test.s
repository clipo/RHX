/******************************************************************************
*
*   Janus WinPREP Test Script
*   ---------------------------------
*
*   Based On:       C:\Packard\JANUS\bin\Random XY Test.MPT
*   Generated By:   WinPREP Version 3.0.0.017
*   Date Generated: 06/03/10 13:51:52
*   Username:       Janus
*   System:         DHD5RV81
*
******************************************************************************/



// The name and path of this test.
char *pszTestName = "Random XY Test";
char *pszTestPath = "C:\\Packard\\JANUS\\bin";


/******************************************************************************
*
*   Runtime Variable Definitions
*
******************************************************************************/

int    Rt_nNbrOfErrorsX = 0;
int    Rt_nNbrOfErrorsY = 0;
int    Rt_nNbrOfErrorsV = 0;
int    Rt_nExecProc_S1  = 100;
char   Rt_szMoveTextX[260];
char   Rt_szMoveTextY[260];
char   Rt_szMoveTextV[260];
int    Rt_nNbrOfMovesMade   = 0;
char   Rt_szNbrOfErrorsZ[260];
char   Rt_szMoveTextZ[260];


int IniAllRtVariables()
{
    strcpy( Rt_szMoveTextX, "0 / 0" );
    strcpy( Rt_szMoveTextY, "0 / 0" );
    strcpy( Rt_szMoveTextV, "0 / 0" );
    strcpy( Rt_szNbrOfErrorsZ, "" );
    strcpy( Rt_szMoveTextZ, "" );

    return 0;
}



/******************************************************************************
*
*   Runtime File Definitions
*
******************************************************************************/

char* NULL = 0; // Global NULL pointer value
    

int IniAllRtFileDefs()
{

    return 0;
}



/******************************************************************************
*
*   Sample List Definitions
*
******************************************************************************/


int IniAllRtSmpListDefs()
{

    return 0;
}



/******************************************************************************
*
*   Well Map Definitions
*
******************************************************************************/


int IniAllWellMapDefs()
{

    MSL_ReconcileWellMapDefs();

    return 0;
}



/******************************************************************************
*
*   Procedure Definitions
*
******************************************************************************/

MP2_PROC_CONTEXT_DEF C00_Initial_User_Query;
MP2_PROC_CONTEXT_DEF C01_Clear_Deck_Warning;
MP2_PROC_CONTEXT_DEF C02_Create_Results_Dialog;
MP2_PROC_CONTEXT_DEF C03_Move_Loop;
MP2_PROC_CONTEXT_DEF C04_Wait_For_User_Response;

int IniAllProcDefs()
{
    MSL_IniProcDef( &C00_Initial_User_Query, "Initial User Query", 1, 0, NULL, sizeof(MP2_PROC_CONTEXT_DEF) );
    MSL_IniProcDef( &C01_Clear_Deck_Warning, "Clear Deck Warning", 3, 0, NULL, sizeof(MP2_PROC_CONTEXT_DEF) );
    MSL_IniProcDef( &C02_Create_Results_Dialog, "Create Results Dialog", 5, 0, NULL, sizeof(MP2_PROC_CONTEXT_DEF) );
    MSL_IniProcDef( &C03_Move_Loop, "Move Loop", 7, 0, NULL, sizeof(MP2_PROC_CONTEXT_DEF) );
    MSL_IniProcDef( &C04_Wait_For_User_Response, "Wait For User Response", 9, 0, NULL, sizeof(MP2_PROC_CONTEXT_DEF) );

    return 0;
}



/******************************************************************************
*
*   Labware Definitions
*
******************************************************************************/

int IniAllLabwareDefs()
{
    IniLabwareDef( "C:\\Packard\\JANUS\\bin\\Random XY Test_Labware.csv" );

    return 0;
}



/******************************************************************************
*
*   User Defined Functions
*
******************************************************************************/

//------------------------------------------------
// Uf_CreateResultsDialog()
//------------------------------------------------

int Uf_CreateResultsDialog(    // 0=Normal; 3=Abort; 12=Stop Procedure
    char*  pPCX )  // Address of procedure context information
{
    int nRet = 0;                       // Load return value into nRet
    MP2_PROC_CONTEXT_DEF* pPC = pPCX;   // Cast pPCX into local procedure context ptr

    int iX = 10;
    int iY =  2;
    int i;
    int nZmotors;
    char szLabel[64];
    char sElapsedTime[40];


    //---------------------------------------------
    // Create the error count dialog
    //---------------------------------------------
    MSL_CreateDialog(0, 1, -1, -1, -1, -1, "Random XY Test Results", 1);

    //---------------------------------------------
    // Create the X, Y and V motor error text boxes
    //---------------------------------------------
    MSL_CreateLabel   (1,100,iX,iY,20,1,"Errors / Moves", 0);
    MSL_CreateEditBox (1,101,iX,-1,20,1,"X motor",NULL, Rt_szMoveTextX,   "TEXT", 0, 64, 0, 0, 8);
    MSL_CreateEditBox (1,102,iX,-1,20,1,"Y motor",NULL, Rt_szMoveTextY,   "TEXT", 0, 64, 0, 0, 8);
    MSL_CreateEditBox (1,103,iX,-1,20,1,"V motor",NULL, Rt_szMoveTextV,   "TEXT", 0, 64, 0, 0, 8);

    //---------------------------------------------
    // Get the number of Z motors
    //---------------------------------------------
    nZmotors = MSL_NumberOfDilutors();

    //---------------------------------------------
    // Create the Z motor error text boxes
    //---------------------------------------------
    for( i = 0; i < nZmotors; i++ )
    {
        sprintf( szLabel, "Z%d motor", i+1 );
        strcpy( &Rt_szMoveTextZ[i*32], "0 / 0" );
        MSL_CreateEditBox (1, 104+i, iX,-1,20,1, szLabel, NULL, &Rt_szMoveTextZ[i*32], "TEXT", 0, 64, 0, 0, 8);
    }
    memset( Rt_szNbrOfErrorsZ, 0, sizeof(Rt_szNbrOfErrorsZ) );

    //---------------------------------------------
    // Create the OK button
    //---------------------------------------------
    MSL_CreatePushBtn (1,116,iX,-1,20,1,"OK",NULL, 0, 0, 0x830);

    //---------------------------------------------
    // Display the dialog
    //---------------------------------------------
    MSL_ShowDialog( 1, 1, 0);

    return nRet;
}
// End of Uf_CreateResultsDialog()


//------------------------------------------------
// Uf_WaitForUser()
//------------------------------------------------

int Uf_WaitForUser(    // 0=Normal; 3=Abort; 12=Stop Procedure
    char*  pPCX )  // Address of procedure context information
{
    int nRet = 0;                       // Load return value into nRet
    MP2_PROC_CONTEXT_DEF* pPC = pPCX;   // Cast pPCX into local procedure context ptr


	MSL_SetControlFocus( 1, 116 );
	MSL_WaitControl( 1, 116, -1 );

    return nRet;
}
// End of Uf_WaitForUser()


//------------------------------------------------
// Uf_RandomMove()
//------------------------------------------------

int Uf_RandomMove(    // 0=Normal; 3=Abort; 12=Stop Procedure
    char*  pPCX )  // Address of procedure context information
{
    int nRet = 0;                       // Load return value into nRet
    MP2_PROC_CONTEXT_DEF* pPC = pPCX;   // Cast pPCX into local procedure context ptr

    // Janus version of the Random XY test.
    // This version runs on both the four and eight tip and
    // on the medium and long deck.

    // Z errors are an array of int's stored as a string variable
    int *pnNbrOfErrorsZ = Rt_szNbrOfErrorsZ;
    int i;

    //------------------------------------------------------------
    // Motor handle variables
    //------------------------------------------------------------
    int xmotor         =    1;  
    int ymotor         =    2;
    int vmotor         =    3;
    int zmotor[8];
    int iNumOfZMotors;


    //------------------------------------------------------------
    // Variables that are filled in from call to MSL_GetMotorInfo
    //------------------------------------------------------------
    int iCanMsgBlock, iMotorType, bInitialized;
    double dDefaultRamp, dDefaultSpeed, dStepSize, dTolerance, dStorage1;


    //------------------------------------------------------------
    // Variables that are filled in from call to MSL_GetMotorStatus
    //------------------------------------------------------------
    int iState;
    int iStatus;


    //------------------------------------------------------------
    // Variables used to calculate next move target
    //------------------------------------------------------------
    int nRandom;
    double dMaxLoc, dMinLoc;
    double dXTarget, dYTarget, dVTarget, dZTarget;
    double dVMaxTargetLoc;
    double dVTargetPrevious;


    //------------------------------------------------------------
    // X rail definitions
    //------------------------------------------------------------
    int X_Rail_Short =  1;
    int X_Rail_Medium = 2;
    int X_Rail_Long =   3;


    //------------------------------------------------------------
    // Make sure the instrument is open!
    //------------------------------------------------------------

    if( MSL_IsInstrumentOpen() == 0 ) return 0;


    //------------------------------------------------------------
    // Get the number of Z motors and load the z motor handles
    //------------------------------------------------------------

    iNumOfZMotors = MSL_NumberOfDilutors();
    for( i = 0; i < iNumOfZMotors; i++ )
        zmotor[i] = MSL_GetZMotorHandle( i+1 );


    //------------------------------------------------------------
    // Calculate X target for next move.
    //------------------------------------------------------------

    MSL_GetMotorInfo( xmotor, &iCanMsgBlock, &iMotorType, &dDefaultRamp, &dDefaultSpeed,
        &dStepSize, &dMaxLoc, &dMinLoc, &dTolerance, &bInitialized, &dStorage1);

    nRandom = rand();

    if(MSL_GetXRailType() == X_Rail_Long)
    {
      // long rail
      dMinLoc = 0.0;     // A1 to A1:  0"
      dMaxLoc = 1079.5;  // A1 to A24: 42.5"
    }
    else
    {
      // assume medium rail
      dMinLoc = 0.0;     // A1 to A1:  0"
      dMaxLoc = 800.1;   // A1 to A18: 31.5"
      if(iNumOfZMotors == 4)
        dMaxLoc = 749.3; // A1 to A17: 29.5"
    }

    // if gripper installed, limit X travel by 8.3" (210mm)
    if(MSL_IsSubsystemPresent("GripperArm"))
      dMaxLoc -= 8.3 * 25.4;

    dXTarget = ((double) nRandom)  / 32767.0 * (dMaxLoc - dMinLoc) + dMinLoc;
    
    printf( "\nX min,max,target = %f,%f,%f", dMinLoc, dMaxLoc, dXTarget );


    //------------------------------------------------------------
    // Calculate Y target for next move.
    //------------------------------------------------------------

    // limits of travel for reference tip based on sweet spot
    if(iNumOfZMotors == 4)
    {
        // computed dMinLoc = -10.64;
        dMinLoc = 0.0   // row A
            - .419*25.4 // row A to back of sweet spot
            + 0.0;      // offset from ref tip 4 to tip 4
        // dMaxLoc = 348.79;
        dMaxLoc = 0.0   // row A
            + 12*25.4   // rwo A to row G (6 * 2")
            + .669*25.4 // row G to front of sweet spot
            + 3*9;      // offset from ref tip 4 to tip 1
    }
    else
    {
        // computed dMinLoc = -42.37;
        dMinLoc = 0.0   // row A
            + 11.63     // row A to back of sweet spot
            - 6*9;      // offset from ref tip 2 to tip 8
        // dMaxLoc = 330.79;
        dMaxLoc = 0.0   // row A
            + 12*25.4   // rwo A to row G (6 * 2")
            + .669*25.4 // row G to front of sweet spot
            + 1*9;      // offset from ref tip 2 to tip 1
    }

    nRandom = rand();
    dYTarget = (((double) nRandom) /32767.0 * (dMaxLoc - dMinLoc) + dMinLoc);

    printf( "\nY min,max,target = %f,%f,%f", dMinLoc, dMaxLoc, dYTarget );


    //------------------------------------------------------------
    // Calculate V target for next move.
    //------------------------------------------------------------

    //-------------------------------------------------------------------------------
    // Note: the varispan number is the desired spacing between tip to tip.
    //
    // 4 / 8 tip varispan differences:
    // 
    //         *                *             
    //         *          tip 2 *  (tip2 is connected to the Y motor.)
    //         *                *            
    //   tip 4 *                *            
    //                          *
    //                          *
    //                          * 
    //                          *
    //
    //   (front of deck)
    // 
    // 4 tip: tip 4 remains stationary when varispan changes.
    // 8 tip: tip 2 remains stationary when varispan changes.
    //
    // When varispan opens on a 4 tip, tip 1 will move in the negative Y direction.
    // When varispan opens on an 8 tip, tip 8 will move in the positive Y direction.  
    //-------------------------------------------------------------------------------
   
    nRandom = rand();
   
    if (nRandom < 20000)          //sometimes just move 9mm
    {
         nRandom = rand();

         // 4 Tip multiprobe (tip4 stationary).
         if(iNumOfZMotors == 4)
         {
             // 4 tip varispan can be fully opened only if Y is beyond the 25mm mark.
             if(dYTarget >25)
             { 
                 // If the reference tip (tip4) isn't near the back of the deck,
                 // then varispan can be any value within its range.
                 dVMaxTargetLoc = dMaxLoc;
             }
             else
             {
                 // If the reference tip (tip4) is near the back of the deck, then
                 // varispan can not be just any value. In this case postion varispan
                 // so tip 4 is located at Y position and tip 1 at minimum Y travel location.
                 // Since actual varispan number is based on tip to tip spacing, need
                 // to divide by total number of tip to tip spacings. In this case 3 spacings. 
                 dVMaxTargetLoc = (dYTarget - dMinLoc)/3;
             }
         }
         // 8 Tip multiprobe (tip2 stationary).
         else
         {
             // Near the front of the deck.
             if(dYTarget > 50)
             { 
                 // Maximum allowable varispan spacing is distance from tip2 to maximum Y travel. 
                 // Since varispan number is tip to tip, divide by 6 spacings.
                 dVMaxTargetLoc = (dMaxLoc - dYTarget)/6 ;
             }
             // Near the rear of the deck.
             else
             {
                 // Maximum allowable varispan spacing is distance from tip2 to minimum Y travel. 
                 // Since varispan number is tip to tip, divide by 1 spacing.
                 dVMaxTargetLoc = (dYTarget - dMinLoc)/1;
             }
         }
 

         if(iNumOfZMotors == 4)
         {
             if (dVMaxTargetLoc>11) dVMaxTargetLoc = 11;
         }
         else
         {
             if (dVMaxTargetLoc>31) dVMaxTargetLoc = 31;
         }
	
         dVTarget = ((double) nRandom)  / 32767.0 * (dVMaxTargetLoc)+9;

    }
    else
    {
         dVTarget = 9;
    }

    printf( "\nV max,target = %f,%f", dVMaxTargetLoc, dVTarget );


    //------------------------------------------------------------
    // Make the movements
    //------------------------------------------------------------
    if(iNumOfZMotors == 4)
    {
        // 4 tip
        // If varispan is closing, do that motion first.
        // if varispan is opening, move X & Y first.

	if(Rt_nNbrOfMovesMade == 0)
            dVTargetPrevious = 9.0;

        if(dVTarget < dVTargetPrevious)
        {
            // varispan closing

	    // move V first
            MSL_SetMotorNextMove( vmotor, dVTarget, 0, 0, 0, 0, 0);
            MSL_SendMotorsForward();
            MSL_StartMovement();
            MSL_WaitForMotorsDone(  10 );
            MSL_FinishAllMotors( 0 );
            dVTargetPrevious = dVTarget;

            // count any V faults
            MSL_GetMotorStatus( vmotor, &iState, &iStatus );
            if (iState == 6) Rt_nNbrOfErrorsV++;

            // now move X & y
            MSL_SetMotorNextMove( xmotor, dXTarget, 0, 0, 0, 0, 0);
            MSL_SetMotorNextMove( ymotor, dYTarget, 0, 0, 0, 0, 0);
            MSL_SendMotorsForward();
            MSL_StartMovement();
            MSL_WaitForMotorsDone(  10 );
            MSL_FinishAllMotors( 0 );

            // count any X or Y faults
            MSL_GetMotorStatus( xmotor, &iState, &iStatus );
            if (iState == 6) Rt_nNbrOfErrorsX++;
            MSL_GetMotorStatus( ymotor, &iState, &iStatus );
            if (iState == 6) Rt_nNbrOfErrorsY++;
        }
        else
        {
            // varispan opening

            // move X & Y first
            MSL_SetMotorNextMove( xmotor, dXTarget, 0, 0, 0, 0, 0);
            MSL_SetMotorNextMove( ymotor, dYTarget, 0, 0, 0, 0, 0);
            MSL_SendMotorsForward();
            MSL_StartMovement();
            MSL_WaitForMotorsDone(  10 );
            MSL_FinishAllMotors( 0 );

            // count any X or Y faults
            MSL_GetMotorStatus( xmotor, &iState, &iStatus );
            if (iState == 6) Rt_nNbrOfErrorsX++;
            MSL_GetMotorStatus( ymotor, &iState, &iStatus );
            if (iState == 6) Rt_nNbrOfErrorsY++;

            // now move V
            MSL_SetMotorNextMove( vmotor, dVTarget, 0, 0, 0, 0, 0);
            MSL_SendMotorsForward();
            MSL_StartMovement();
            MSL_WaitForMotorsDone(  10 );
            MSL_FinishAllMotors( 0 );
            dVTargetPrevious = dVTarget;

            // count any V faults
            MSL_GetMotorStatus( vmotor, &iState, &iStatus );
            if (iState == 6) Rt_nNbrOfErrorsV++;
        }
    }
    else
    {
        // 8 tip
        // X, Y, and V can all be moved at once
        MSL_SetMotorNextMove( xmotor, dXTarget, 0, 0, 0, 0, 0);         
        MSL_SetMotorNextMove( ymotor, dYTarget, 0, 0, 0, 0, 0);
        MSL_SetMotorNextMove( vmotor, dVTarget, 0, 0, 0, 0, 0);

	// adjust V & Y speeds and add any needed predelay time
        MSL_AdjustYVSpeeds();

	// Now make the movements
        MSL_SendMotorsForward();
        MSL_StartMovement();
        MSL_WaitForMotorsDone(  10 );
        MSL_FinishAllMotors( 0 );

        // Make sure moves finished without a fault.
        // If any faulted, count it

        MSL_GetMotorStatus( xmotor, &iState, &iStatus );
        if (iState == 6) Rt_nNbrOfErrorsX++;

        MSL_GetMotorStatus( ymotor, &iState, &iStatus );
        if (iState == 6) Rt_nNbrOfErrorsY++;

        MSL_GetMotorStatus( vmotor, &iState, &iStatus );
        if (iState == 6) Rt_nNbrOfErrorsV++;
    }	



    //------------------------------------------------------------
    // Calculate targets for iNumOfZMotors. Make about 2/3 of the moves
    // with all n zrack programmed to move to the same target.
    // Make the other moves sending each zrack to a different target
    //------------------------------------------------------------

    nRandom = rand();
    if (nRandom < 20000)
    {
        nRandom = rand();
        dZTarget = ((double) nRandom)  / 32767.0 * 150 + 10;

        for( i = 0; i < iNumOfZMotors; i++ )
            MSL_SetMotorNextMove( zmotor[i], dZTarget  , 0, 0, 0, 0, 0);
    }
    else
    {
        for( i = 0; i < iNumOfZMotors; i++ )
        {
            nRandom = rand();
            dZTarget = ((double) nRandom)  / 32767.0 * 150 + 10;
            MSL_SetMotorNextMove( zmotor[i], dZTarget  , 0, 0, 0, 0, 0);
        }
    }


    //------------------------------------------------------------
    // Now make the Z movements down
    //------------------------------------------------------------

    MSL_SendMotorsForward();
    MSL_StartMovement();
    MSL_WaitForMotorsDone(  10 );
    MSL_FinishAllMotors( 0 );


    //------------------------------------------------------------
    // Make sure moves finished without a fault.
    // If any faulted, count it
    //------------------------------------------------------------

    for( i = 0; i < iNumOfZMotors; i++ )
    {
        MSL_GetMotorStatus( zmotor[i], &iState, &iStatus );

        if (iState == 6) pnNbrOfErrorsZ[i]++;
    }


    //------------------------------------------------------------
    // Now send the zracks back to a safe height
    //------------------------------------------------------------

    for( i = 0; i < iNumOfZMotors; i++ )
        MSL_SetMotorNextMove( zmotor[i], 160, 0, 0, 0, 0, 0);


    //------------------------------------------------------------
    // Now make the movements up
    //------------------------------------------------------------

    MSL_SendMotorsForward();
    MSL_StartMovement();
    MSL_WaitForMotorsDone(  10 );
    MSL_FinishAllMotors( 0 );


    //------------------------------------------------------------
    // Make sure moves finished without a fault.
    // If any faulted, count it
    //------------------------------------------------------------

    for( i = 0; i < iNumOfZMotors; i++ )
    {
        MSL_GetMotorStatus( zmotor[i], &iState, &iStatus );

        if (iState == 6) pnNbrOfErrorsZ[i]++;
    }


    //------------------------------------------------------------
    // Increment total number of cycles
    //------------------------------------------------------------

    Rt_nNbrOfMovesMade++;


    //------------------------------------------------------------
    // Create status strings for the dialog box
    //------------------------------------------------------------

    sprintf( Rt_szMoveTextX, "%d / %d", Rt_nNbrOfErrorsX, Rt_nNbrOfMovesMade );
    sprintf( Rt_szMoveTextY, "%d / %d", Rt_nNbrOfErrorsY, Rt_nNbrOfMovesMade );
    sprintf( Rt_szMoveTextV, "%d / %d", Rt_nNbrOfErrorsV, Rt_nNbrOfMovesMade );
    for( i = 0; i < iNumOfZMotors; i++ )
        sprintf( &Rt_szMoveTextZ[i*32], "%d / %d", pnNbrOfErrorsZ[i], Rt_nNbrOfMovesMade*2 );


    //------------------------------------------------------------
    // Force the dialog to refresh
    //------------------------------------------------------------

    MSL_UpdateControl( 1, 101 );
    MSL_UpdateControl( 1, 102 );
    MSL_UpdateControl( 1, 103 );

    for( i = 0; i < iNumOfZMotors; i++ )
        MSL_UpdateControl( 1, 104+i );

    return nRet;
}
// End of Uf_RandomMove()




/******************************************************************************
*
*   Procedure Functions:
*
*   Each procedure name is prefixed with a 'P' followed by one or
*   more pairs of hexidecimal digits.  The number of pairs indicates
*   the nesting level of the procedure node in the test outline.
*   The value of each pair is the offset of the node at each level
*   from its parent.
*
******************************************************************************/

/******************************************************************************
*
*   P00_Initial_User_Query()
*
*   <Reserved for text entered into the procedure's comment page.>
*
******************************************************************************/

int P00_Initial_User_Query()
{
    MP2_PROC_CONTEXT_DEF *pPC = &C00_Initial_User_Query;
    int  nRet;              // Funct. return value
    int  nFileIndex = 0;    // Current File Index
    int  nLoopCount = 0;    // Number of unskipped procedure loops
    int  bDone;             // Last procedure loop flag
    int  nDlg;              // Dialog Id
    int  nCurPage;          // Current Dialog Page Number
    int  nNxtPage;          // Next Dialog Page Number
    int  nX, nY;            // Control origin
    int  nW, nH;            // Control size
    int  nMaxY = 0;         // Max Y position
    MP2_DATE stMinDate;     // Minimum Date
    MP2_DATE stMaxDate;     // Maximum Date
    MP2_TIME stMinTime;     // Minimum Time
    MP2_TIME stMaxTime;     // Maximum Time


    // Set the current procedure context.
    MSL_SetCurrentProcContext( pPC, 0, 0 );

    // Create the dialog box.
    nDlg = MSL_GetAvailableDialogId();
    MSL_CreateDialog( 0, nDlg, -1, -1, -1, -1,
                      "Initial User Query", 0 );

    // Create page 1: Label, prompts and collection.
    MSL_CreateLabel( nDlg, 2, 1, 1, 0, 1, "", 0 );
    MSL_CreateEditBox( nDlg, 3, -175, 3, 15, 1, "Number of movements to make", "Number of movement cycles to make", &Rt_nExecProc_S1, "INT", 1., 2000000000., 0., 0,  0x60 );
    MSL_GetControlGeom( nDlg, 3, &nX, &nY, &nW, &nH );
    if( nMaxY < (nY + nH) ) nMaxY = nY + nH;
    MSL_CreateCollection( nDlg, 1, "2,3", 0, 0 );
    MSL_ShowControl( nDlg, 1, 0 );

    // Create push buttons...
    nMaxY += 28;
    MSL_CreatePushBtn( nDlg, 10001, 1, -nMaxY, 10, 1, "< &Back", "Display Previous Page", 0, 0, 0);
    MSL_CreatePushBtn( nDlg, 10002,-1, -nMaxY, 10, 1, "&Next >", "Display Next Page", 0, 0, 0);
    MSL_CreatePushBtn( nDlg, 10003,24, -nMaxY, 10, 1, "&Start", "Begin Test Execution", 0, 0, 0x10);
    MSL_CreatePushBtn( nDlg, 10004,-1, -nMaxY, 10, 1, "&Abort", "Quit Test Now", 0, 0, 0);
    MSL_ShowControl( nDlg, 10001, 0 );
    MSL_ShowControl( nDlg, 10002, 0 );

    // Procedure query loop.
    pPC->nProcLimit = 1;
    for( pPC->nProcLoop = 0; pPC->nProcLoop <= pPC->nProcLimit; pPC->nProcLoop++ )
    {
        nFileIndex = pPC->nProcLoop;

        // If at or past the last loop, set the done flag.
        bDone = (pPC->nProcLoop >= pPC->nProcLimit);

        // Child procedure calls would be written here...

        // If done, break now.
        if( bDone ) break;

        // Increment the loop count.
        nLoopCount++;

        // Reset the current procedure context.
        MSL_SetCurrentProcContext( pPC, 1, 0 );

        // Sound the buzzer for 1/8 second
        MSL_Beep( 500, 0.125 );

        // Display the dialog box.
        nCurPage = 0;
        nNxtPage = 1;
        MSL_ShowDialog( nDlg, 1, 0 );

        // Monitor user button selections...
        while( 1 )
        {
            // Was there a change page request?
            if( nCurPage != nNxtPage )
            {
                if( nCurPage > 0 )   // Hide current page (if any)
                {
                    MSL_ShowControl( nDlg, nCurPage, 0 );   // Hide current page
                }
                if( nNxtPage > 0 )   // Show next page (if any)
                {
                    MSL_ShowControl( nDlg, nNxtPage, 1 );   // Show next page
                    MSL_UpdateControl( nDlg, nNxtPage );    // Update control values on next page
                    MSL_SetControlFocus( nDlg, nNxtPage );  // Give Focus to first control on next page
                }
                else break;  // Quit if next page not > 0

                nCurPage = nNxtPage;
            }

            // Set button states according to the current page.
            MSL_EnableControl( nDlg, 10001, (nCurPage > 1) );
            MSL_EnableControl( nDlg, 10002, (nCurPage < 1) );
            MSL_ShowControl(   nDlg, 10003, (nCurPage == 1) );

            // Wait for the user to click a button.
            nRet = MSL_WaitControlList( nDlg, "10001,10002,10003,10004", 0, -1, 0 );

            switch( nRet )
            {
                case 10001:   // Back
                    nNxtPage = nCurPage - 1;
                    if( nNxtPage < 1 ) nNxtPage = 1;
                    break;

                case 10002:   // Next
                    nNxtPage = nCurPage + 1;
                    if( nNxtPage > 1 ) nNxtPage = 1;
                    break;

                case 10003:   // Start
                    nNxtPage = 0;
                    break;

                case 10004:   // Abort?
                    MSL_DeleteDialog( nDlg, 0 );
                    MSL_Abort();
                    return -1;
            }

        } //<End Monitor button selections>

        // Hide the dialog box.
        MSL_ShowDialog( nDlg, 0, 0 );

    } //<End Procedure Loop>

    // Delete the dialog box.
    MSL_DeleteDialog( nDlg, 0 );

    // Remove disposable tips (if any)
    MSL_RemoveDTs();

    return 0;

} //<End P00_Initial_User_Query()>



/******************************************************************************
*
*   P01_Clear_Deck_Warning()
*
*   <Reserved for text entered into the procedure's comment page.>
*
******************************************************************************/

int P01_Clear_Deck_Warning()
{
    MP2_PROC_CONTEXT_DEF *pPC = &C01_Clear_Deck_Warning;
    int  nRet;              // Funct. return value
    int  nFileIndex = 0;    // Current File Index
    int  nLoopCount = 0;    // Number of unskipped procedure loops
    int  bDone;             // Last procedure loop flag


    // Set the current procedure context.
    MSL_SetCurrentProcContext( pPC, 0, 0 );

    // Toplevel procedures start with dilutor number 1.
    EGS_SetNextDilutor( 1 );

    // Procedure loop.
    pPC->nProcLimit = 1;
    for( pPC->nProcLoop = 0; pPC->nProcLoop <= pPC->nProcLimit; pPC->nProcLoop++ )
    {
        nFileIndex = pPC->nProcLoop;

        // If at or past the last loop, set the done flag.
        bDone = (pPC->nProcLoop >= pPC->nProcLimit);

        // Child procedure calls would be written here...

        // If done, break now.
        if( bDone ) break;

        // Increment the loop count.
        nLoopCount++;

        // Reset the current procedure context.
        MSL_SetCurrentProcContext( pPC, 1, 0 );

        // Sound the buzzer for 1/8 second
        MSL_Beep( 500, 0.125 );

        // Display User Message.
        nRet = MSL_MessageDialog( 0,        // No dialog owner
                    "Clear Deck Warning",       // Dialog Title
                    "Remove EVERYTHING from the deck!",     // Dialog Message
                    1,      // Icon: Information
                    1,      // Btns: OK
                    1,      // Default to 1st button
                    0 );        // Reserved flags field

        // Test User Reply: 2=>Cancel, 7=>No
        if( (nRet == 2) || (nRet == 7) ) return -1;

    } //<End Procedure Loop>

    return 0;

} //<End P01_Clear_Deck_Warning()>



/******************************************************************************
*
*   P02_Create_Results_Dialog()
*
*   <Reserved for text entered into the procedure's comment page.>
*
******************************************************************************/

int P02_Create_Results_Dialog()
{
    MP2_PROC_CONTEXT_DEF *pPC = &C02_Create_Results_Dialog;
    int  nRet;              // Funct. return value
    int  nFileIndex = 0;    // Current File Index
    int  nLoopCount = 0;    // Number of unskipped procedure loops
    int  bDone;             // Last procedure loop flag


    // Set the current procedure context.
    MSL_SetCurrentProcContext( pPC, 0, 0 );

    // Toplevel procedures start with dilutor number 1.
    EGS_SetNextDilutor( 1 );

    // Procedure loop.
    pPC->nProcLimit = 1;
    for( pPC->nProcLoop = 0; pPC->nProcLoop <= pPC->nProcLimit; pPC->nProcLoop++ )
    {
        nFileIndex = pPC->nProcLoop;

        // If at or past the last loop, set the done flag.
        bDone = (pPC->nProcLoop >= pPC->nProcLimit);

        // Child procedure calls would be written here...

        // If done, break now.
        if( bDone ) break;

        // Increment the loop count.
        nLoopCount++;

        // Reset the current procedure context.
        MSL_SetCurrentProcContext( pPC, 1, 0 );

        // Make sure string parameters comming from a file are auto allocated
        MSL_SetRtFileStringAutoAlloc( 1 );

        // Invoke the User Function...
        nRet = Uf_CreateResultsDialog( pPC );
        if( nRet ==  3 ) return -1;    // Check for abort
        if( nRet == 12 ) return  0;    // Check for done

        // Release any auto allocated strings.
        MSL_SetRtFileStringAutoAlloc( 0 );

    } //<End Procedure Loop>

    return 0;

} //<End P02_Create_Results_Dialog()>



/******************************************************************************
*
*   P03_Move_Loop()
*
*   <Reserved for text entered into the procedure's comment page.>
*
******************************************************************************/

int P03_Move_Loop()
{
    MP2_PROC_CONTEXT_DEF *pPC = &C03_Move_Loop;
    int  nRet;              // Funct. return value
    int  nFileIndex = 0;    // Current File Index
    int  nLoopCount = 0;    // Number of unskipped procedure loops
    int  bDone;             // Last procedure loop flag


    // Set the current procedure context.
    MSL_SetCurrentProcContext( pPC, 0, 0 );

    // Toplevel procedures start with dilutor number 1.
    EGS_SetNextDilutor( 1 );

    // Procedure loop.
    pPC->nProcLimit = Rt_nExecProc_S1;
    for( pPC->nProcLoop = 0; pPC->nProcLoop <= pPC->nProcLimit; pPC->nProcLoop++ )
    {
        nFileIndex = pPC->nProcLoop;

        // If at or past the last loop, set the done flag.
        bDone = (pPC->nProcLoop >= pPC->nProcLimit);

        // Child procedure calls would be written here...

        // If done, break now.
        if( bDone ) break;

        // Increment the loop count.
        nLoopCount++;

        // Reset the current procedure context.
        MSL_SetCurrentProcContext( pPC, 1, 0 );

        // Make sure string parameters comming from a file are auto allocated
        MSL_SetRtFileStringAutoAlloc( 1 );

        // Invoke the User Function...
        nRet = Uf_RandomMove( pPC );
        if( nRet ==  3 ) return -1;    // Check for abort
        if( nRet == 12 ) return  0;    // Check for done

        // Release any auto allocated strings.
        MSL_SetRtFileStringAutoAlloc( 0 );

    } //<End Procedure Loop>

    return 0;

} //<End P03_Move_Loop()>



/******************************************************************************
*
*   P04_Wait_For_User_Response()
*
*   <Reserved for text entered into the procedure's comment page.>
*
******************************************************************************/

int P04_Wait_For_User_Response()
{
    MP2_PROC_CONTEXT_DEF *pPC = &C04_Wait_For_User_Response;
    int  nRet;              // Funct. return value
    int  nFileIndex = 0;    // Current File Index
    int  nLoopCount = 0;    // Number of unskipped procedure loops
    int  bDone;             // Last procedure loop flag


    // Set the current procedure context.
    MSL_SetCurrentProcContext( pPC, 0, 0 );

    // Toplevel procedures start with dilutor number 1.
    EGS_SetNextDilutor( 1 );

    // Procedure loop.
    pPC->nProcLimit = 1;
    for( pPC->nProcLoop = 0; pPC->nProcLoop <= pPC->nProcLimit; pPC->nProcLoop++ )
    {
        nFileIndex = pPC->nProcLoop;

        // If at or past the last loop, set the done flag.
        bDone = (pPC->nProcLoop >= pPC->nProcLimit);

        // Child procedure calls would be written here...

        // If done, break now.
        if( bDone ) break;

        // Increment the loop count.
        nLoopCount++;

        // Reset the current procedure context.
        MSL_SetCurrentProcContext( pPC, 1, 0 );

        // Make sure string parameters comming from a file are auto allocated
        MSL_SetRtFileStringAutoAlloc( 1 );

        // Invoke the User Function...
        nRet = Uf_WaitForUser( pPC );
        if( nRet ==  3 ) return -1;    // Check for abort
        if( nRet == 12 ) return  0;    // Check for done

        // Release any auto allocated strings.
        MSL_SetRtFileStringAutoAlloc( 0 );

    } //<End Procedure Loop>

    return 0;

} //<End P04_Wait_For_User_Response()>



/******************************************************************************
*
*   main()
*
******************************************************************************/

int main(int argc, char **argv)
{
    int nErr;

    // Set the EGS dump table and single step modes as well as
    // the evaluation level.
    EGS_SetDumpMode( 0 );
    EGS_SetSingleStep( 0 );
    EGS_SetEvaluationLevel( 0 );

    // Initialize runtime variables.
    IniAllRtVariables();

    // Load Instrument Data
    nErr = MSL_CreateMachine(argv[0]);
    if( nErr ) return;

    // Initialize Instrument
    nErr = MSL_InitializeMachine( 0 );
    if( nErr ) return;

    // Initialize file, well map and labware definitions.
    IniAllRtFileDefs();
    IniAllRtSmpListDefs();
    IniAllWellMapDefs();
    IniAllProcDefs();
    IniAllLabwareDefs();

    // Call each 1st level procedure in the outline.
    // Quit test if any procedure returns a failure.
    nErr = P00_Initial_User_Query();
    if( nErr ) return;

    nErr = P01_Clear_Deck_Warning();
    if( nErr ) return;

    nErr = P02_Create_Results_Dialog();
    if( nErr ) return;

    nErr = P03_Move_Loop();
    if( nErr ) return;

    nErr = P04_Wait_For_User_Response();
    if( nErr ) return;

}

// End of Script
